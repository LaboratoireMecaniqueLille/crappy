# coding: utf-8

"""
This example demonstrates the use of the Synchronizer Block. It does not
require any specific hardware to run, but necessitates the matplotlib Python
module to be installed.

The Synchronizer Block takes inputs from several Blocks, and interpolates the
target labels on the timestamps of another label taken as a reference. This
behavior is very similar to that of the Multiplexer Block, except the
Multiplexer uses a time basis independent of the received labels. The
Synchronizer is useful when signals need to be synchronized with a reference
label, for example with data derived from image processing.

Here, the idea is to visually demonstrate how several signals with different
data rates can be interpolated by the Synchronizer Block on a target time base.
Two labels are generated by two Generators at different frequencies, as well as
one random label generated by another Generator and considered as a reference.
They are all sent to a Synchronizer for interpolation, and the interpolated
data is sent to a Grapher for display.

After starting this script, just watch how the two interpolated labels are now
synchronized on the time base of the reference labels. They are then all
displayed at the same frequency by the Grapher, whereas they have originally
very different frequencies. You can try to change the different frequencies and
see what the result is. This demo ends after 22s. You can also hit CTRL+C to
stop it earlier, but it is not a clean way to stop Crappy.
"""

import crappy
from typing import Optional
from time import sleep
import random


class RandomPath(crappy.blocks.generator_path.meta_path.Path):
  """This custom Generator Path outputs a random value within given bounds, and
  waits for a given delay before returning this value.

  Both the values and the timestamps are therefore random. This class is used
  to demonstrate that the Synchronizer works as expected in this example, and
  not because of some regularity in the input data.
  """

  def __init__(self,
               time_range: tuple[float, float],
               value_range: tuple[float, float]) -> None:
    """Sets the arguments and initializes the parent class.

    Args:
      time_range: The possible seconds range for sleeping before returning the
        generated value.
      value_range: The possible range for the randomly generated values.
    """

    super().__init__()

    self._time_range: tuple[float, float] = time_range
    self._value_range: tuple[float, float] = value_range

  def get_cmd(self, data: dict[str, list]) -> Optional[float]:
    """Returns a randomly generated value after sleeping a random number of
    seconds."""

    sleep(random.uniform(*self._time_range))
    return random.uniform(*self._value_range)


if __name__ == '__main__':

  # This Generator generates a random signal considered as a reference, and
  # sends it to the Synchronizer Block for interpolation
  gen_ref = crappy.blocks.Generator(
      # Generating a random signal to take as a reference time base
      ({'type': 'RandomPath', 'time_range': (0.50, 0.150),
        'value_range': (-1, 1)},),
      cmd_label='ref',  # The label carrying the generated signal
      freq=3,  # Frequency is a prime number to ensure signals from several
      # Blocks will be desynchronized

      # Sticking to default for the other arguments
  )

  # This Generator generates a sine signal to send to the Synchronizer Block
  # for interpolation
  gen_sig_1 = crappy.blocks.Generator(
      # Generating a sine signal of period 20s and amplitude 2
      ({'type': 'Sine', 'freq': 0.05, 'amplitude': 2, 'condition': None},),
      cmd_label='sig_1',  # The label carrying the generated signal
      freq=7,  # Frequency is a prime number to ensure signals from several
      # Blocks will be desynchronized

      # Sticking to default for the other arguments
  )

  # This Generator generates a sine signal to send to the Synchronizer Block
  # for interpolation
  gen_sig_2 = crappy.blocks.Generator(
      # Generating a constant signal of value 0.5
      ({'type': 'Constant', 'value': 0.5, 'condition': 'delay=20'},),
      cmd_label='sig_2',  # The label carrying the generated signal
      spam=True,  # Spamming enabled, otherwise only one value would get sent
      freq=5,  # Frequency is a prime number to ensure signals from several
      # Blocks will be desynchronized

      # Sticking to default for the other arguments
  )

  sync = crappy.blocks.Synchronizer(reference_label='ref',
                                    time_label='t(s)',
                                    labels_to_sync=('sig_1', 'sig_2'),
                                    freq=20)

  # This Grapher displays the interpolated data transmitted by the Synchronizer
  # Block. The 'sig_1' and 'sig_2' signals are now synchronized with the 'ref'
  # signal, and the 'ref' is preserved
  graph = crappy.blocks.Grapher(
      # The names of the labels to plot on the graph
      ('t(s)', 'ref'), ('t(s)', 'sig_1'), ('t(s)', 'sig_2'),
      interp=False,  # Displaying the data points only, no lines, to clearly
      # distinguish them
      length=40,  # Only displaying the last 40 received values, so that the
      # data points remain always clearly visible
      freq=2,  # Updating the graph twice every second

      # Sticking to default for the other arguments
  )

  # Linking the Block so that the information is correctly sent and received
  crappy.link(gen_ref, sync)
  crappy.link(gen_sig_1, sync)
  crappy.link(gen_sig_2, sync)
  crappy.link(sync, graph)

  # Mandatory line for starting the test, this call is blocking
  crappy.start()
